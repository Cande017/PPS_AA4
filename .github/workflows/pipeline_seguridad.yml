name: Pipeline DevSecOps Integral (CI/CD)

# DISPARADOR: Se ejecuta cuando alguien hace push a la rama 'main'
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch: # Para poder lanzarlo a mano si hace falta

jobs:
  integracion-continua:
    name: Build y Analisis de Seguridad
    runs-on: ubuntu-latest # Usamos una máquina Linux de GitHub

    steps:
    # 1. Bajar el código del repositorio
    - name: Checkout del código
      uses: actions/checkout@v4

    # 2. Instalar Go (Versión del proyecto)
    - name: Configurar Go 1.25.5
      uses: actions/setup-go@v4
      with:
        go-version: '1.25.5'

    # 3. REQUISITO: Análisis de Seguridad Estático (SAST)
    # Usamos Gosec para buscar vulnerabilidades en el código
    - name: Ejecutar Análisis de Seguridad (Gosec)
      uses: securego/gosec@master
      with:
        args: ./...

    # 4. REQUISITO: Ejecución de Tests
    # Si los tests fallan, el pipeline se detiene aquí
    - name: Ejecutar Tests Unitarios
      run: go test -v ./...

    # 5. REQUISITO: Build Automático
    # Si todo lo anterior está bien, creamos el ejecutable para Linux (nuestro destino)
    - name: Construir Aplicación (Build)
      run: |
        mkdir -p build
        CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags "-s -w" -v -o build/pps_app ./...

    # 6. Guardar el binario para que el siguiente Job lo pueda usar
    - name: Subir Artefacto
      uses: actions/upload-artifact@v4
      with:
        name: pps_app
        path: build/pps_app

  despliegue-seguro:
    name: Despliegue en Servidor Linux
    needs: integracion-continua # Solo se desplegará si el CI sale perfecto
    runs-on: ubuntu-latest
    
    steps:
    - name: Descargar el binario construido
      uses: actions/download-artifact@v4
      with:
        name: pps_app
        path: build

    # 7. REQUISITO: Enviar el archivo al servidor mediante el bastión
    # Usamos los secretos para no dejar ninguna IP o puerto a la vista
    - name: Copiar binario al servidor (SCP)
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USER }}
        port: ${{ secrets.SSH_PORT }}
        key: ${{ secrets.SSH_KEY }}
        source: "build/pps_app"
        target: "/home/${{ secrets.SSH_USER }}"
        strip_components: 1


    - name: Ejecución remota y Reinicio
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USER }}
        port: ${{ secrets.SSH_PORT }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          set -e
          # Definir variables dentro del script
          TARGET="/opt/app_cyber5"
          TS=$(date +%s)
          
          # Ir a la carpeta de la app
          cd $TARGET


          # Paso 1: Si ya hay una app corriendo, le hacemos un backup por si las moscas
          if [ -f pps_app ]; then
            cp pps_app pps_app.bak.$TS
          fi

          # Paso 2: Ponemos el nuevo binario en su sitio y le damos permisos
          mv /home/${{ secrets.SSH_USER }}/pps_app $TARGET/pps_app
          chmod +x $TARGET/pps_app

          # Paso 3: Reiniciamos el servicio para que cargue la nueva versión
          sudo systemctl restart pps_app.service

          # Paso 4: TEST DE SALUD (Health Check)
          # Esperamos un poco y comprobamos si la app responde en el puerto
          sleep 5
          
          
          if curl -f http://127.0.0.1:8080/health; then
            echo "SUCCESS: App estable."
          else
            echo "FAIL: Haciendo rollback..."
            mv pps_app.bak.$TS pps_app
            sudo systemctl restart pps_app.service
            exit 1
          fi